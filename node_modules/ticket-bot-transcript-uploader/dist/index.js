"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMessages = void 0;
const axios_1 = __importDefault(require("axios"));
const v10_1 = require("discord-api-types/v10");
async function generateMessages(messages, premiumKey, api, giveState) {
    let array = new Array();
    messages = messages.reverse();
    const oneMessage = messages.first();
    await oneMessage.guild?.members.fetch();
    const channels = await oneMessage.guild?.channels.fetch();
    if (!channels)
        return;
    let userArray = [];
    const channelsArray = [];
    for (const e of channels.values()) {
        channelsArray.push({
            id: e?.id,
            name: e?.name,
        });
    }
    for (const m of messages.values()) {
        const attachments = () => {
            let attachmentsArray = new Array();
            for (let a of m.attachments.values()) {
                if (giveState)
                    giveState(`Uploading attachments...`);
                const imageURL = axios_1.default.post(`${api}/upload?key=${premiumKey}`, {
                    url: a.url,
                    name: a.name,
                    contentType: a.contentType,
                });
                attachmentsArray.push({
                    contentType: a.contentType || null,
                    height: a.height || null,
                    id: a.id,
                    size: a.size,
                    name: a.name,
                    imagePromise: imageURL,
                    width: a.width || null,
                });
            }
            return attachmentsArray;
        };
        const components = () => {
            let array = [];
            for (let i = 0; i < m.components.length; i++) {
                const c = m.components[i];
                let comparray = [];
                for (let j = 0; j < c.components.length; j++) {
                    const comp = c.components[j];
                    if (comp.type == v10_1.ComponentType.Button) {
                        comparray.push({
                            type: comp.type,
                            key: comp.customId,
                            style: comp.style,
                            emoji: comp.emoji,
                            label: comp.label,
                            url: comp.url,
                        });
                    }
                }
                array.push(comparray);
            }
            return array;
        };
        const roles = () => {
            let roleArr = [];
            m.channel.guild.roles.cache.forEach((r) => {
                roleArr.push({
                    name: r.name,
                    id: r.id,
                    hexColor: r.hexColor,
                });
            });
            return roleArr;
        };
        const reactionsCache = () => {
            let reactarray = [];
            m.reactions.cache.forEach((r) => {
                reactarray.push({
                    count: r.count,
                    emoji: {
                        animated: r.emoji.animated,
                        id: r.emoji.id,
                        name: r.emoji.name,
                    },
                });
            });
            return reactarray;
        };
        const users = async () => {
            m.channel.client.users.cache.forEach((u) => {
                userArray.push({
                    bot: u.bot,
                    displayAvatarURL: u.displayAvatarURL(),
                    globalName: u.globalName,
                    displayName: u.displayName,
                    flags: u.flags?.toArray(),
                    id: u.id,
                    tag: u.tag,
                    username: u.username,
                });
            });
            let matches = [];
            // Find user mention in the message content
            if (m.content.match(/<@(!|)[0-9]{18,19}>/g))
                matches = m.content.match(/<@(!|)[0-9]{18,19}>/g);
            // Find user mention in the embeds
            for (let e of m.embeds) {
                if (e.description?.match(/<@(!|)[0-9]{18,19}>/g)) {
                    let descMatches = e.description.match(/<@(!|)[0-9]{18,19}>/g);
                    for (let d of descMatches)
                        matches.push(d);
                }
                if (e.fields)
                    for (let f of e.fields) {
                        if (f.name?.match(/<@(!|)[0-9]{18,19}>/g)) {
                            let nameMatches = f.name.match(/<@(!|)[0-9]{18,19}>/g);
                            for (let n of nameMatches)
                                matches.push(n);
                        }
                        if (f.value?.match(/<@(!|)[0-9]{18,19}>/g)) {
                            let valueMatches = f.value.match(/<@(!|)[0-9]{18,19}>/g);
                            for (let v of valueMatches)
                                matches.push(v);
                        }
                    }
            }
            if (matches)
                for (let u of matches) {
                    const uid = u.replace(/<@(!|)|>/g, "");
                    if (!userArray.find((user) => user.id === uid)) {
                        try {
                            let fetched = oneMessage.client.users.cache.get(uid);
                            if (!fetched) {
                                if (giveState)
                                    giveState(`Fetching user ${uid}`);
                                console.log(`Fetching user ${uid}`);
                                fetched = await oneMessage.client.users.fetch(uid);
                            }
                            if (fetched)
                                userArray.push({
                                    bot: fetched.bot,
                                    displayAvatarURL: fetched.displayAvatarURL(),
                                    globalName: fetched.globalName,
                                    displayName: fetched.displayName,
                                    flags: fetched.flags?.toArray(),
                                    id: fetched.id,
                                    tag: fetched.tag,
                                    username: fetched.username,
                                });
                        }
                        catch {
                            userArray.push({
                                bot: false,
                                displayAvatarURL: "https://cdn.discordapp.com/embed/avatars/0.png",
                                globalName: uid,
                                displayName: uid,
                                flags: [],
                                id: 0,
                                tag: "0000",
                                username: uid,
                            });
                        }
                    }
                }
            return userArray;
        };
        const recipient = m.channel.isDMBased()
            ? () => {
                let channel = m.channel;
                return {
                    bot: channel.recipient?.bot,
                    displayAvatarURL: channel.recipient?.displayAvatarURL(),
                    displayName: channel.recipient?.displayName,
                    flags: channel.recipient?.flags?.toArray(),
                    id: channel.recipient?.id,
                    tag: channel.recipient?.tag,
                    username: channel.recipient?.username,
                };
            }
            : null;
        const authorRoles = () => {
            let array = [];
            m.guild?.members.cache.get(m.author.id)?.roles.cache.forEach((r) => {
                array.push({
                    name: r.name,
                    id: r.id,
                    hexColor: r.hexColor == "#000000" ? "#f3f4f5" : r.hexColor,
                });
            });
            return array;
        };
        const toPush = {
            author: {
                ...m.author,
                displayName: m.author.displayName,
                flags: m.author.flags?.toArray(),
                displayAvatarURL: m.author.displayAvatarURL({ forceStatic: false }),
                roles: authorRoles(),
            },
            attachments: attachments(),
            channel: {
                dmBased: m.channel.isDMBased(),
                id: m.channel.id,
                isThread: m.channel.isThread(),
                messages: m.client.channels.cache.get(m.channel.id),
                name: m.client.channels.cache.get(m.channel.id).name,
                ownerId: m.channel.isThread() ? m.channel.ownerId : null,
                parent: m.channel.isThread() ? m.channel.parent : null,
                recipient: recipient,
                users: await users(),
            },
            components: components(),
            createdAt: m.createdAt?.toISOString(),
            content: m.content,
            editedAt: m.editedAt,
            embeds: m.embeds,
            guild: {
                channels: channelsArray,
                iconURL: m.guild?.iconURL(),
                id: m.guild?.id ?? null,
                name: m.guild?.name,
                roles: roles(),
            },
            hasThread: m.hasThread,
            id: m.id,
            interaction: {
                commandName: m.interaction?.commandName,
                user: {
                    bot: m.interaction?.user.bot,
                    displayAvatarURL: m.guild?.members.cache.get(m.interaction?.user.id || "")?.displayAvatarURL({ forceStatic: false }) ||
                        m.interaction?.user.displayAvatarURL({ forceStatic: false }),
                    flags: m.interaction?.user.flags?.toArray(),
                    id: m.interaction?.user.id,
                    tag: m.interaction?.user.tag,
                    username: m.interaction?.user.username,
                },
            },
            member: {
                displayAvatarURL: m.guild?.members.cache.get(m.member?.user.id || "")?.displayAvatarURL({ forceStatic: false }) ||
                    m.member?.user.displayAvatarURL({ forceStatic: false }),
                displayHexColor: m.member?.displayHexColor,
                nickname: m.member?.nickname,
                roles: {
                    color: {
                        hexColor: m.member?.roles.color?.hexColor,
                    },
                    hexColor: m.member?.roles.color?.hexColor,
                    hoist: {
                        name: m.member?.roles.hoist?.name,
                    } || null,
                    icon: {
                        url: m.member?.roles.icon?.iconURL || null,
                    } || null,
                    id: m.member?.roles.highest.id,
                    name: m.member?.roles.highest.name,
                },
            } || null,
            mentions: {
                everyone: m.mentions.everyone,
            },
            system: m.system,
            reactions: {
                cache: reactionsCache(),
            },
            reference: {
                guildId: m.reference?.guildId,
                messageId: m.reference?.messageId,
            } || null,
            textBased: m.channel.isTextBased(),
            topic: m.channel.type == v10_1.ChannelType.GuildText ? m.channel.topic : null,
            type: m.type,
            voiceBased: m.channel.isVoiceBased(),
            webhookId: m.webhookId,
        };
        array.push({
            ...toPush,
        });
    }
    // let startTime = Date.now();
    // Resolve all promises
    for (let i = 0; i < array.length; i++) {
        const a = array[i];
        for (let j = 0; j < a.attachments.length; j++) {
            const attachment = a.attachments[j];
            attachment.url = (await attachment.imagePromise).data;
            attachment.imagePromise = undefined;
            // console.log(`Resolved attachment ${attachment.id} in ${Date.now() - startTime}ms`)
            // startTime = Date.now();
        }
    }
    for (let i = 0; i < array.length; i++) {
        if (i === 0) {
            // Remove duplicate users
            const userArray = array[i].channel.users;
            const unique = userArray.filter((v, i, a) => a.findIndex((t) => t.id === v.id) === i);
            array[i].channel.users = unique;
        }
        else {
            array[i].channel.users = null;
        }
    }
    return array;
}
exports.generateMessages = generateMessages;
//# sourceMappingURL=index.js.map